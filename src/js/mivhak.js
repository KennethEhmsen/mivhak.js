/**
 * The constructor.
 * See Mivhal.defaults for available options.
 * 
 * @param {DOMElement} selection
 * @param {Object} options
 */
function Mivhak( selection, options )
{   
    // Bail if there are no resources
    if(!selection.getElementsByTagName('PRE').length) return;
    
    this.$selection = $( selection );
    this.setOptions( options );
    this.init();
}

/**
 * Check if a given string represents a supported method
 * @param {string} method
 */
Mivhak.methodExists = function( method )
{
    return typeof method === 'string' && Mivhak.methods[method];
};

/**
 * Initiate the code viewer.
 */
Mivhak.prototype.init = function() 
{
    this.initState();
    this.parseSources();
    this.createUI();
    this.callMethod('showTab',0); // Show first tab initially
    this.applyOptions();
};

/**
 * Apply the options that were set by the user. This function is called when
 * Mivhak is initiated, and every time the options are updated.
 */
Mivhak.prototype.applyOptions = function() 
{
    this.callMethod('setHeight', this.options.height);
    if(this.options.collapsed) this.callMethod('collapse');
};

/**
 * Initiate this instance's state.
 */
Mivhak.prototype.initState = function() 
{
    this.state = {
        lineWrap:   true,
        collapsed:  false,
        height:     0,
        activeTab:  null,   // Updated by tabs.showTab
        sources:    []      // Generated by parseSources()
    };
};

/**
 * Set or update this instance's options.
 * @param {object} options
 */
Mivhak.prototype.setOptions = function( options ) 
{
    // If options were already set, update them
    if( typeof this.options !== 'undefined' )
        this.options = $.extend(true, {}, this.options, options, readAttributes(this.$selection[0]));
    
    // Otherwise, merge them with the defaults
    else this.options = $.extend(true, {}, Mivhak.defaults, options, readAttributes(this.$selection[0]));
};

/**
 * Call one of Mivhak's methods. See Mivhak.methods for available methods.
 * To apply additional arguments, simply pass the arguments after the methodName
 * i.e. callMethod('methodName', arg1, arg2).
 * This method is also called internally when making a method call through jQuery
 * i.e. $('#el').mivhak('methodName', arg1, arg2);
 * 
 * @param {string} methodName
 */
Mivhak.prototype.callMethod = function( methodName )
{
    if(Mivhak.methodExists(methodName))
    {
        // Call the method with the original arguments, removing the method's name from the list
        var args = [];
        Array.prototype.push.apply( args, arguments );
        args.shift();
        Mivhak.methods[methodName].apply(this, args);
    }
};

/**
 * Create the user interface.
 */
Mivhak.prototype.createUI = function() 
{
    this.tabs = Mivhak.render('tabs',{mivhakInstance: this});
    this.topbar = Mivhak.render('top-bar',{mivhakInstance: this});
    this.notifier = Mivhak.render('notifier');
    
    this.$selection.prepend(this.tabs.$el);
    this.$selection.prepend(this.topbar.$el);
    this.tabs.$el.prepend(this.notifier.$el);
    
    if(this.options.caption) {
        this.caption = Mivhak.render('caption',{text: this.options.caption});
        this.$selection.append(this.caption.$el);
    }
    
    if(this.options.runnable) this.createLivePreview();
};

/**
 * Calculate the height in pixels.
 * 
 * auto: Automatically calculate the height based on the number of lines.
 * min: Calculate the height based on the height of the tab with the maximum number of lines
 * max: Calculate the height based on the height of the tab with the minimum number of lines
 * average: Calculate the height based on the average height of all tabs
 * 
 * @param {string|number} h One of (auto|min|max|average) or a custom number
 * @returns {Number}
 */
Mivhak.prototype.calculateHeight = function(h)
{
    var heights = [],
        padding = this.options.padding*2,
        i = this.tabs.tabs.length;

    while(i--)
        heights.push(getEditorHeight($(this.tabs.tabs[i].pre))+padding);

    if('average' === h) return average(heights);
    if('shortest' === h) return min(heights);
    if('longest' === h) return max(heights);
    if('auto' === h) return getEditorHeight($(this.activeTab.pre))+padding;
    if(!isNaN(h)) return parseInt(h);
};

/**
 * Loop through each PRE element inside this.$selection and store it's options
 * in this.state.sources, merging it with the default option values.
 */
Mivhak.prototype.parseSources = function()
{
    var $this = this;
    this.$selection.find('pre').each(function(){
        $this.state.sources.push($.extend({},Mivhak.sourceDefaults,{pre:this, content: this.textContent},readAttributes(this)));
    });
};

/**
 * Create the live preview iframe window
 */
Mivhak.prototype.createLivePreview = function()
{
    this.preview = Mivhak.render('live-preview',{sources: this.state.sources});
    this.tabs.$el.append(this.preview.$el);
};

/**
 * Remove all generated elements, data and events.
 * 
 * TODO: keep initial HTML
 */
Mivhak.prototype.destroy = function() 
{
    this.$selection.empty();
};

/* test-code */
testapi.mivhak = Mivhak;
/* end-test-code */